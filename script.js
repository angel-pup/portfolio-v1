//generate gameData object for tracking score across all games played, on website load
let gameData = {
    rock: {
        ties: 0,
        wins: 0,
        losses: 0
    },
    paper: {
        ties: 0,
        wins: 0,
        losses: 0
    },
    scissors: {
        ties: 0,
        wins: 0,
        losses: 0
    }
}


/**
 *
 * @param previousOutcome the previous result generated by the computer, for use with RNG manipulation
 * @param previousChanceArray the previously generated chance array, to calculate this next game's RNG
 * @returns {(string|*[]) []} returns this game's computer outcome, alone with the newly calculated chance array
 */
function generateRandomOutcome(previousOutcome, previousChanceArray) {

    //declare local variables
    let outcome
    let chanceArray = [...previousChanceArray]
    let sumChance, randomChoice

    //manipulate future RNG based on previous results
    switch(previousOutcome) {
        case "R":
            if(chanceArray[0] > 50.0) {
                chanceArray[0] -= 2
                chanceArray[1]++
                chanceArray[2]++
            }
            break
        case "P":
            if(chanceArray[1] > 50.0) {
                chanceArray[1] -= 2
                chanceArray[0]++
                chanceArray[2]++
            }
            break
        case "S":
            if(chanceArray[2] > 50.0) {
                chanceArray[2] -= 2
                chanceArray[0]++
                chanceArray[1]++
            }
            break
        default:
        //do nothing
    }

    //find random choice based on previous outcome
    sumChance = chanceArray.reduce((accumulator, currentValue) => accumulator + currentValue)
    randomChoice = Math.random() * sumChance

    //translate outcome to string equivalent
    if(randomChoice > (sumChance - chanceArray[2])) {
        outcome = "S"
    }
    else if(randomChoice > (sumChance - chanceArray[2] - chanceArray[1])) {
        outcome = "P"
    } else {
        outcome = "R"
    }

    return [outcome, chanceArray]
}

/**
 *
 * @param compOut computer's choice
 * @param userInput user's choice
 * @returns {string} result of the game
 */
function alertOutcome(compOut, userInput) {

    //declare local variable to store cleaned input
    let userIn = userInput.toUpperCase()

    //check if there is a tie, update gameData accordingly
    if(compOut === userIn) {
        switch(userIn) {
            case "R":
                gameData.rock.ties++
                break
            case "P":
                gameData.paper.ties++
                break
            case "S":
                gameData.scissors.ties++
                break
            default:
            //do nothing
        }
        return "Tie!"
    }

    //find who won, and return the appropriate string, with minor error checking
    switch(userIn) {
        case "R":
            if(compOut === "S") {
                gameData.rock.wins++
                return "You win! Computer choose " + compOut + "!"
            }
            gameData.rock.losses++
            return "You lose. Computer choose " + compOut + "."
        case "P":
            if(compOut === "R") {
                gameData.paper.wins++
                return "You win! Computer choose " + compOut + "!"
            }
            gameData.paper.losses++
            return "You lose. Computer choose " + compOut + "."
        case "S":
            if(compOut === "P") {
                gameData.scissors.wins++
                return "You win! Computer choose " + compOut + "!"
            }
            gameData.scissors.losses++
            return "You lose. Computer choose " + compOut + "."
        default:
            return "Invalid input, please try again."
    }
}

/**
 * Callable function for running the game
 */
function playGame() {

    //declare local variables and gameResults object
    let cont = true
    let userChoice = "none"
    let compPrevious = "none"
    let chanceArray = [100.0, 100.0, 100.0]
    let gameResults

    //enter loop
    while(cont) {

        //prompt user for their choice this round
        userChoice = prompt("Rock, Paper, or Scissors? [ Enter 'R', 'P', or 'S' ]")

        //store the this game's result and new chance array in local object
        gameResults = generateRandomOutcome(compPrevious, chanceArray) //decompose bug found

        //manual decomposition to patch bug, storing results in more easily manipulated data
        compPrevious = gameResults[0]
        chanceArray = [...gameResults[1]]

        //alert the user of the game results, using alertOutcome to feath the appropriate results
        alert(alertOutcome(compPrevious, userChoice))

        //check if user wishes to continue playing
        cont = confirm("Would you like to play again? [ Click OK to continue or Cancel to quit ]")
    }

    //goodbye!
    alert("Thanks for playing!")

    //log updated game data, for debugging and out of general interest
    console.log("\nResults:")
    for (let x in gameData) {
        console.log(x)
        for (let y in gameData[x]) {
            console.log('\t', y, gameData[x][y])
        }
    }
}